<!doctype html>

<title>d3 experiments</title>

<meta charset="utf-8">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="viewport" content="initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no">
<style>
body {
  background: #111;
  margin: 0;
}

.time .x.axis line.major {
  stroke: transparent;
}
.time .x.axis line.minor {
  stroke: #232323;
}
.time .axis .line {
  shape-rendering: crispEdges;
}
.time .axis text {
  fill: #ddd;
  font-size: 12px;
  font-weight: bold;
  font-family: sans-serif;
  text-anchor: start !important;
}
.time .x.axis .domain {
  display: none;
}
.time .area {
  fill: rgba(63, 169, 245, .8);
  /*
  stroke: #fff;
  stroke-width: 2;
  */
}
.time .line {
  fill: transparent;
  stroke: #3fa9f5;
  stroke-width: 3px;
}
.time .y.axis .tick:first-child, .time .yText.axis .tick:first-child {
  display: none;
}
.time .y.axis line {
  stroke: #6a7072;
}
.time .y.axis text {
  display: none;
}
.time .y.axis .domain, .time .yText.axis .domain {
  display: none;
}
</style>
<script src="d3.v3.js"></script>

<body>
  
<script>
(function(){
  // use zoom behaviour for zoom+pan, resample data in the naive way based on the zooming scale, 'fetch' (= generate random) data during or after 'zooming'
  
  var width = innerWidth;
  var height = innerHeight;
  
  var padding = {
    bottom: 25
  };

//    .append('g').attr('transform', 'translate(10, 10)');

  var x = d3.time.scale()
    .domain([0, new Date])
    .range([0, width]);
  var y = d3.scale.linear()
    .domain([0, 200])
    .range([height - padding.bottom, 0]);
  
  var xAxis = d3.svg.axis()
    .scale(x)
    .orient('bottom')
    .ticks(8)
    .tickSubdivide(true)
    .tickPadding(6)
    .tickSize(height);
  var yAxis = d3.svg.axis()
    .scale(y)
    .orient('left')
    .ticks(5)
    .tickPadding(6)
    .tickSize(-width)
    .tickFormat(function(d) { return d + ' W'; });
  
  var area = d3.svg.area()
    //.interpolate('step-after')
    .x(function(d) { return x(d.at); }) // TODO resampled
    .y0(height - padding.bottom)//height - 25) // TODO proper scaling
    .y1(function(d) { return y(d.value) / 2; });
  var line = d3.svg.line()
    //.interpolate('step-after')
    .x(function(d) { return x(d.at); })
    .y(function(d) { return y(d.value) / 2; });
    
  var chart;
  
  window.xAxis = xAxis;
  window.x = x;
  
  var distance = 0;
  
  function onzoom() {
    //d3.event.transform(x);
    var axis = chart.select('.x.axis').call(xAxis);
    axis.selectAll('text')
      .attr('x', 5)
      .attr('y', height - 15);
    
    
    var lines = axis.selectAll('line');
    var ndistance = 0;
    if (lines[0] && lines[0].length > 1) {
      for (var i = 0; i < lines[0].length; i++) {
        ndistance = (lines[0][i + 1].transform.baseVal.getItem(0).matrix.e - lines[0][i].transform.baseVal.getItem(0).matrix.e) / 2;
        if (ndistance > 0) {
          distance = ndistance;
          break;
        }
      }
    }
    //console.log(distance);
    lines.style('stroke-width', distance).attr('x1', distance / 2).attr('x2', distance / 2);
    
    // FIXME this is slow
    //console.log(xAxis.tickSize(), zoom.scale(), zoom.translate());
    chart.select('.container')
      .attr('transform', 'translate(' + zoom.translate()[0] + ', 0) scale(' + zoom.scale() + ', 1)');
    
    chart.select('.line').attr('filter', '');
      //.attr('d', area);
    
    //console.log(xAxis.tickSize())
  }
    
  function doneMoving() {
    draw();
  }
  function draw() {
    var start = x.domain()[0];
    var duration = +x.domain()[1] - +x.domain()[0];
    //var factor = 1/5;
    var n = width / 8;
    var interval = duration / n;
    
    // FIXME
    // 1. clamp 'interval' to one of the values in couchm (have feeds_and_datastreams tell about them)
    // 2. use code below to create the right url
    
    /*
  var params = {
    feed: feed,
    datastream: datastream,
    interval: interval,
    duration: duration, <<< just /1000 and use 'seconds'
    start: start_datetime
  };
  var units = {
    second: 1, seconds: 1,
    minute: 60, minutes: 60,
    hour: 60 * 60, hours: 60 * 60,
    day: 60 * 60 * 24, days: 60 * 60 * 24,
    week: 60 * 60 * 24 * 7, weeks: 60 * 60 * 24 * 7,
    month: 60 * 60 * 24 * 31, months: 60 * 60 * 24 * 31,
    year: 60 * 60 * 24 * 366, years: 60 * 60 * 24 * 366
  };
  //var parsed = /(\d+)([a-z]+)/.exec(duration);
  //var ms = parseInt(parsed[1]) * units[parsed[2]] * 1000;
    
    
    '/_design/energy_data/_show/historical'
    

    var arr = [];
    for (var key in args)
      arr.push(key + '=' + encodeURIComponent(args[key]));
    url += '?' + arr.join('&');
    */
    
    
    // also, use domains to set the initial view, so that we donâ€™t have to load unavailable data for 30+ years
    
    //d3.json(url, function(error, data) {
      var fakeData = [];
      fakeData[0] = {
        at: +start - duration,
        value: 20 + Math.random() * 50
      };
      for (var i = 1; i < n * 3; i++) {
        fakeData.push({
          at: new Date(+fakeData[i - 1].at + interval),
          value: Math.max(0, fakeData[i - 1].value + Math.random() * 40 - 20)
        });
      }
        
      //area.data(fakeData);
      //console.log(area());
      
      y.domain([0, d3.max(fakeData.map(function(d) { return d.value })) + 50]);
      var axis2 = chart.select('.y.axis').transition().duration(1000).call(yAxis);
      axis2 = chart.select('.yText.axis').transition().duration(1000).call(yAxis);
      axis2.selectAll('text')
        .attr('x', 5)
        .attr('y', -10);

      chart.select('.area')
        .datum(fakeData)
        .attr('d', area)
        .attr('transform', 'scale(' + (1 / zoom.scale()) + ', 1) translate(' + -zoom.translate()[0] + ', 0)');
  
      chart.select('.line')
        .datum(fakeData)
        .attr('d', line)
        .attr('transform', 'scale(' + (1 / zoom.scale()) + ', 1) translate(' + -zoom.translate()[0] + ', 0)')
        .attr('filter', 'url(#lineShadow)');
    //});

    /*
    chart.selectAll('.timespan')
        .data(x.ticks(10))
      .enter().append('rect')
        .attr('class', 'timespan')
        .attr('x', x)
        .attr('y', 0)
        .attr('width', x(x.ticks(10)[1]) / 2)
        .attr('height', height)
  //      .attr('transform', 'translate(' + -x(x.ticks(10)[1]) / 2 + ', 0)')
    */
        /*
      .enter().append('line')
        .attr('class', 'timespan')
        .attr('x1', x)
        .attr('x2', x)
        .attr('y1', 0)
        .attr('y2', height);
        */
        /*
    chart.selectAll('.timelabel')
        .data(x.ticks(10))
      .enter().append('text')
        .attr('class', 'timelabel')
        .attr("x", x)
        .attr("y", height)
        //.attr("dx", -3) // padding-right
        //.attr("dy", ".35em") // vertical-align: middle
        .attr("text-anchor", "start") // text-align: right
        .text(x.tickFormat(20));
        */
  }
  var zoom = d3.behavior.zoom().x(x).scaleExtent([1, Infinity]).on('zoom', onzoom);
  
  chart = d3.select('body').append('svg')
    .attr('class', 'time')
    .attr('width', width)
    .attr('height', height)
    .call(zoom)
    .append('g')
      .attr('transform', 'translate(0, 0)')
//      .call(zoom);
  
  chart.append('g')
    .attr('class', 'x axis');
    //.attr('transform', 'translate(0,' + (height - 25) + ')');
    
    
    chart.append('g')
      .attr('class', 'y axis');
  
  /*
  chart.append('defs').append('clipPath')
    .attr('id', 'clip')
    .append('rect')
      .attr('width', width)
      .attr('height', height);
  */
  
  //chart.graph = chart.svg.append('g')
  //  .attr('transform', 'translate(' + chart.dim.margin.left + ',' + chart.dim.margin.top + ')');
  
  chart.append('g')
    .attr('class', 'container')
    .append('path')
      .attr('class', 'area')
      //.attr('clip-path', 'url(#clip)')
      .datum([])
      .attr('d', area);

      // drop shadow from http://stackoverflow.com/questions/6088409/svg-drop-shadow-using-css3
  var filter = chart.append('filter')
    .attr('id', 'lineShadow')
    .attr('height', '130%');
  filter.append('feGaussianBlur')
    .attr('in', 'SourceAlpha')
    .attr('stdDeviation', 10);
  filter.append('feOffset')
    .attr('dx', 0)
    .attr('dy', 5)
    .attr('result', 'offsetblur');
  var merge = filter.append('feMerge');
  merge.append('feMergeNode');
  merge.append('feMergeNode')
    .attr('in', 'SourceGraphic');
  chart.select('.container').append('path')
    .attr('class', 'line')
    //.attr('clip-path', 'url(#clip)')
    .datum([])
    .attr('d', line);  
      
  var gradient = chart.append('defs').append('linearGradient')
    .attr('id', 'leftGradient')
    .attr('x1', '0%')
    .attr('x2', '100%')
    .attr('y1', '0%')
    .attr('y2', '0%');
  gradient.append('stop').attr('offset', '0%').style('stop-color', '#111111').style('stop-opacity', 1);
  gradient.append('stop').attr('offset', '100%').style('stop-color', '#111111').style('stop-opacity', 0);
  
  chart.append('rect')
    .attr('width', 90)
    .attr('height', height)
    .attr('fill', 'url(#leftGradient)');
  
  chart.append('g')
    .attr('class', 'yText axis');

  onzoom();
  
  
  d3.select(window).on('mouseup', doneMoving);
  (function() {
    var timeout;
    chart.on('mousewheel', function(event) {
      if (timeout) clearTimeout(timeout);
      timeout = setTimeout(doneMoving, 500);
    });
  })();
  // TODO meh need to listen to touch events to also catch the drag stuff. might just as well start working on pinch gesture. but for now, maybe add a range slider???
  
  draw();
})();
</script>
